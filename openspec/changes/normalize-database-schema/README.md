# 数据库规范化重构 - 提案总结

## 📋 快速概览

这是一份完整的数据库重构提案，旨在解决当前数据库存在的**设计问题**，实现**三范式规范化**，为应用的长期发展奠定基础。

---

## ❌ 当前数据库存在的问题

### 1. 数据冗余严重
- `customer_name` 在每条作业中重复存储，导致更新异常风险
- `customer_contact` 作为字符串存储，无法管理一客户多联系人

### 2. 缺乏外键约束
- 无法保证数据引用的完整性
- 删除操作风险大，容易导致孤立数据

### 3. 不符合三范式
- **第一范式问题**: 存在冗余信息（如重复的客户数据）
- **第二范式问题**: 非主键属性之间有依赖关系
- **第三范式问题**: 存在传递依赖（如通过 job_number 间接关联 customer）

### 4. 功能支持受限
- 无法追踪 BOM（零件组成关系）
- 无法记录完整的生产步骤和附件
- 无法灵活添加备注

---

## ✅ 新设计的优势

### 1. 完全符合三范式
- ✅ 所有原子值，无冗余
- ✅ 完全依赖于主键，无部分依赖
- ✅ 消除传递依赖

### 2. 数据规范化
- 15 个规范化表，清晰的实体关系
- 完整的外键约束和级联删除
- 消除数据冗余，确保数据一致性

### 3. 灵活的扩展性
- 支持 BOM（零件树）管理
- 支持生产步骤追踪
- 支持多类型附件管理
- 支持灵活的备注系统
- 支持使用统计（助力分析）

### 4. 业务流程完整
```
客户 → 联系人 → 采购订单 → 作业 → 订单明细 → 生产步骤 → 发货
```

---

## 📊 新数据库结构（15 个表）

### 核心实体表（5 个）
| 表名 | 作用 | 主要字段 |
|------|------|---------|
| `customer` | 客户管理 | id, customer_name, usage_count, last_used |
| `customer_contact` | 联系人管理 | id, customer_id, contact_name, contact_email |
| `purchase_order` | 采购订单 | id, po_number, oe_number, contact_id, is_active |
| `job` | 作业管理 | id, job_number, po_id, priority |
| `order_item` | 订单明细 | id, job_id, part_id, line_number, quantity, status |

### 零件与生产表（5 个）
| 表名 | 作用 | 主要字段 |
|------|------|---------|
| `part` | 零件主表 | id, drawing_number, revision, is_assembly, production_count |
| `part_tree` | BOM（零件组成） | id, parent_id, child_id, quantity |
| `process_template` | 工艺模板 | id, part_id, shop_code, description |
| `step_tracker` | 步骤追踪 | id, order_item_id, process_template_id, status |
| `part_attachment` | 零件附件 | id, part_id, file_type, file_path |

### 发货与支持表（5 个）
| 表名 | 作用 | 主要字段 |
|------|------|---------|
| `shipment` | 发货单 | id, packing_slip_number, invoice_number |
| `shipment_item` | 发货明细 | id, order_item_id, shipment_id, quantity |
| `drawing_file` | 图纸文件 | id, part_id, file_path, is_active |
| `folder_mapping` | 客户文件夹映射 | id, customer_id, folder_name |
| `note` | 通用备注 | id, po_id/part_id/job_id/.../content |

---

## 🔄 数据关系图

```
customer (1) ────────→ (N) customer_contact (1) ────→ (N) purchase_order
                                                              ↓
                                                        (1) job (N)
                                                              ↓
                                                        (1) order_item (N)
                                                           ↙      ↘
                                                    (N) part (1)  (1) shipment_item (N)
                                                        ↓                  ↓
                                              part_tree (自引用)    (1) shipment

part (1) ────→ (N) part_attachment
       ├───→ (N) drawing_file
       └───→ (N) process_template ──→ (N) step_tracker
```

---

## 📝 关键特性说明

### 1. 客户使用统计
```sql
-- 自动追踪使用频率，便于排序常用客户
customer.usage_count    -- 该客户的订单总数
customer.last_used      -- 最后使用时间

customer_contact.usage_count  -- 联系人被使用的次数
customer_contact.last_used    -- 联系人最后被使用的时间
```

### 2. 零件版本管理
```sql
-- 支持版本链
part_1: drawing_number='ABC-001', revision='A', previous_id=NULL
part_2: drawing_number='ABC-001', revision='B', previous_id=part_1.id
part_3: drawing_number='ABC-001', revision='C', previous_id=part_2.id
```

### 3. BOM 支持
```sql
-- 多级零件组成关系（自引用）
装配体-A (id=1)
  ├─ 子装配体-B (id=2), qty=1
  │   ├─ 零件-C (id=3), qty=2
  │   └─ 零件-D (id=4), qty=3
  └─ 零件-E (id=5), qty=5
```

### 4. 生产步骤追踪
```sql
-- 完整的生产过程追踪（支持条码扫描）
order_item (GM223-1314-9, qty=40)
  ├─ step_tracker[1]: TURN → COMPLETED (2025-12-20 08:00-10:30)
  ├─ step_tracker[2]: MILL → IN_PROGRESS (2025-12-20 10:45-)
  └─ step_tracker[3]: DRILL → PENDING
```

### 5. 灵活的备注系统
```sql
-- 可在任何实体上添加备注（采购订单、零件、订单明细等）
note.po_id = 1 → "该订单需要加急处理"
note.part_id = 5 → "该零件库存不足"
note.order_item_id = 1 → "零件表面有轻微划伤，已确认可用"
```

---

## 🎯 需要你确认的关键问题

| # | 问题 | 建议 | 你的决定 |
|----|------|------|---------|
| 1 | 旧数据是否保留？ | 保留旧库用于参考，不影响新库 | 不必保留, 我已手动备份 |
| 2 | 如何处理 358 条历史记录？ | 设计 ETL 迁移脚本 | 当前数据库文件jobs表的358条记录需要作为数据源存入新的数据结构中 |
| 3 | 是否需要 ID 映射表？ | 便于应用过渡期引用 | 不需要 |
| 4 | 应用改造优先级？ | 先改造客户/搜索，后改造生产功能 | 需说明如何改造, 我会评估使用api实现排序还是使用数据库排序 |
| 5 | 预期上线时间？ | 影响工作计划和优先级 | 不必考虑 |

---

## 📈 工作计划总览

### 阶段 1: 方案评审 (2h)
- [ ] 你评审本提案
- [ ] 确认表结构和字段定义
- [ ] 答复上述 5 个关键问题

### 阶段 2: 数据库初始化 (3-4h)
- [ ] 删除所有旧迁移脚本 (001-019)
- [ ] 创建新迁移脚本 #001（创建 15 个表）
- [ ] 创建新迁移脚本 #002（创建索引，可选）
- [ ] 验证 `npm run db:migrate` 成功

### 阶段 3: 数据迁移 (2-3h，可选)
- [ ] 设计 ETL 脚本
- [ ] 迁移 358 条历史记录
- [ ] 验证数据完整性

### 阶段 4: API 改造 (40-50h)
- [ ] 改造 7 个主要 API 模块
- [ ] 编写单元测试
- [ ] 验证数据正确性

### 阶段 5: 前端改造 (30-40h)
- [ ] 改造 React Query hooks
- [ ] 改造 6 个主要页面
- [ ] 编写集成测试

### 阶段 6: 测试验证 (15-20h)
- [ ] 数据库完整性测试
- [ ] API 和前端测试
- [ ] 性能测试

### 阶段 7: 上线部署 (4-6h)
- [ ] 备份旧数据库
- [ ] 执行迁移
- [ ] 部署新应用
- [ ] 监控运行

**总工作量**: 96-127 小时 ≈ 2-3 周

---

## 📚 提案文档说明

| 文档 | 内容 | 阅读对象 |
|------|------|---------|
| [proposal.md](./proposal.md) | 完整的需求分析与表结构设计 | **你需要评审** |
| [design.md](./design.md) | 详细的设计文档（字段说明、业务含义、约束规则） | 开发人员参考 |
| [tasks.md](./tasks.md) | 具体的工作项分解、依赖关系、验收标准 | 项目管理参考 |

---

## 🔐 风险评估与缓解

| 风险 | 影响 | 缓解方案 |
|------|------|---------|
| 数据迁移错误 | 数据丢失 | 保留旧库、编写详细的 ETL 脚本、多次验证 |
| 应用改造遗漏 | 功能断裂 | 分阶段改造、充分测试、灰度部署 |
| 性能下降 | 用户体验差 | 创建适当的索引、进行性能测试 |
| 回滚困难 | 问题扩大 | 保持旧系统可用、准备回滚脚本 |

---

## ✨ 设计优点总结

1. ✅ **符合三范式**: 消除冗余，确保数据一致性
2. ✅ **引用完整性**: 完整的外键约束，防止脏数据
3. ✅ **灵活扩展**: BOM、生产追踪、附件、备注等功能完备
4. ✅ **使用统计**: 支持客户频度排序、分析等
5. ✅ **生产就绪**: 包含审计字段、时间戳、级联删除等
6. ✅ **易于维护**: 清晰的关系、规范的命名、详细的文档

---

## 🚀 下一步行动

### 请你做以下三件事：

1. **审核提案**
   - 仔细阅读 [proposal.md](./proposal.md)
   - 检查 15 个表的结构是否符合需求
   - 是否需要调整字段或添加新列？

2. **回答关键问题**
   - 旧数据如何处理？
   - 应用改造优先级？
   - 预期上线时间？
   - *(见上面的"需要你确认的关键问题"表格)*

3. **给出批准意见**
   - ✅ 同意该方案，开始执行？
   - ❓ 需要调整或讨论某些方面？
   - ❌ 有其他顾虑或建议？

---

## 📞 联系与支持

- 有任何设计问题？查看 [design.md](./design.md) 了解详细说明
- 有任何工作计划问题？查看 [tasks.md](./tasks.md) 了解具体任务
- 需要讨论或修改？随时提出，我会更新提案

---

**提案时间**: 2025-01-06  
**状态**: ⏳ 等待你的评审和批准  
**后续**: 收到你的反馈后，我们可以开始执行任务计划

---

## 一句话总结

🎯 **从一个不规范的单表设计，演进到一套完整、规范、可扩展的 15 个表的新数据库架构，支持完整的制造业工作流程。**
