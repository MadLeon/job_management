function main(workbook: ExcelScript.Workbook, lines: string[]) {
    try {
        // è°ƒè¯•ï¼šæ£€æŸ¥æ¥æ”¶åˆ°çš„æ•°æ®ç»“æ„
        console.log(`ğŸ“Š lines ç±»å‹: ${typeof lines}, isArray: ${Array.isArray(lines)}`);
        console.log(`ğŸ“Š lines.length: ${lines.length}`);
        if (lines.length > 0) {
            console.log(`ğŸ“Š lines[0] ç±»å‹: ${typeof lines[0]}, isArray: ${Array.isArray(lines[0])}`);
            console.log(`ğŸ“Š lines[0] å€¼: ${JSON.stringify(lines[0]).substring(0, 100)}...`);
        }

        // å¤„ç†åµŒå¥—æ•°ç»„é—®é¢˜ï¼šPower Automate å¯èƒ½ä¼šä¼ é€’ [[...]] è€Œä¸æ˜¯ [...]
        let processLines = lines;
        if (Array.isArray(lines) && lines.length > 0) {
            // æƒ…å†µ 1ï¼šlines[0] æ˜¯ JSON åºåˆ—åŒ–çš„å­—ç¬¦ä¸²æ•°ç»„
            if (typeof lines[0] === 'string') {
                try {
                    const parsed = JSON.parse(lines[0]);
                    if (Array.isArray(parsed)) {
                        console.log("âš ï¸  æ£€æµ‹åˆ° JSON åºåˆ—åŒ–çš„æ•°ç»„å­—ç¬¦ä¸²ï¼Œæ­£åœ¨è§£æ...");
                        processLines = parsed;
                        console.log(`âœ“ è§£æåè¡Œæ•°: ${processLines.length}`);
                    }
                } catch (parseError) {
                    // ä¸æ˜¯ JSONï¼Œç»§ç»­ä½¿ç”¨åŸå§‹æ•°æ®
                    console.log("â„¹ï¸  lines[0] ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼ŒæŒ‰åŸå§‹å­—ç¬¦ä¸²å¤„ç†");
                }
            }
            // æƒ…å†µ 2ï¼šlines[0] æ˜¯æ•°ç»„ï¼ˆåµŒå¥—æ•°ç»„ [[...]]ï¼‰
            else if (Array.isArray(lines[0])) {
                console.log("âš ï¸  æ£€æµ‹åˆ°åµŒå¥—æ•°ç»„ï¼Œæ­£åœ¨å±•å¹³...");
                processLines = [].concat(...(lines as unknown as string[][]));
                console.log(`âœ“ å±•å¹³åè¡Œæ•°: ${processLines.length}`);
            }
        }

        const sheet = workbook.getWorksheet("Report");
        if (!sheet) {
            console.log("âŒ é”™è¯¯ï¼šå·¥ä½œè¡¨ 'Report' ä¸å­˜åœ¨");
            return;
        }

        const table = sheet.getTable("Table2");
        if (!table) {
            console.log("âŒ é”™è¯¯ï¼šè¡¨ 'Table2' ä¸å­˜åœ¨");
            return;
        }

        const columnCount = table.getColumns().length;
        console.log(`âœ“ è¡¨åˆ—æ•°: ${columnCount}`);
        console.log(`âœ“ å¾…å¤„ç†è¡Œæ•°: ${processLines.length}`);

        // ============ é˜¶æ®µ 1ï¼šå‡†å¤‡ï¼ˆè¯»å–è¡¨æ•°æ®ï¼‰============
        console.log("ğŸ“‹ [é˜¶æ®µ 1] è¯»å–è¡¨æ•°æ®...");
        let poIndex: number;
        let orderIDIndex: number;

        try {
            poIndex = table.getColumnByName("PO").getIndex();
            console.log(`âœ“ PO åˆ—ç´¢å¼•: ${poIndex}`);
        } catch (e) {
            console.log(`âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ° 'PO' åˆ—`);
            console.log(`å¯ç”¨åˆ—: ${table.getColumns().map((col: ExcelScript.TableColumn) => col.getName()).join(", ")}`);
            return;
        }

        try {
            orderIDIndex = table.getColumnByName("Order Item ID").getIndex();
            console.log(`âœ“ Order Item ID åˆ—ç´¢å¼•: ${orderIDIndex}`);
        } catch (e) {
            console.log(`âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ° 'Order Item ID' åˆ—`);
            console.log(`å¯ç”¨åˆ—: ${table.getColumns().map((col: ExcelScript.TableColumn) => col.getName()).join(", ")}`);
            return;
        }

        const dataRange = table.getRangeBetweenHeaderAndTotal();
        let values = dataRange.getValues();

        console.log(`âœ“ è¡¨æ•°æ®è¡Œæ•°: ${values.length}`);

        // ============ é˜¶æ®µ 2ï¼šæ„å»º PO æ˜ å°„ï¼ˆè®°å½•æ¯ä¸ª PO çš„è¡Œç´¢å¼•ï¼‰============
        console.log("ğŸ—‚ï¸  [é˜¶æ®µ 2] æ„å»º PO æ˜ å°„...");
        const poMap = new Map<string, number[]>();

        for (let i = 0; i < values.length; i++) {
            const po = values[i][poIndex] as string;
            if (po && po.trim()) {
                if (!poMap.has(po)) {
                    poMap.set(po, []);
                }
                poMap.get(po)!.push(i);
            }
        }

        console.log(`âœ“ PO æ˜ å°„å¤§å°: ${poMap.size}`);

        // ============ é˜¶æ®µ 3ï¼šå¤„ç†æ–°æ•°æ®ï¼ˆæ”¶é›†æ’å…¥æ“ä½œï¼‰============
        console.log("ğŸ“ [é˜¶æ®µ 3] å¤„ç†æ–°æ•°æ®...");
        interface Insertion {
            index: number;
            rows: (string | number | boolean)[][];
        }
        const insertions: Insertion[] = [];
        let newPoInsertionOffset = 0;  // åªç”¨äºæ–° PO çš„æœ«å°¾æ’å…¥
        const poInsertionCount = new Map<string, number>();  // æ¯ä¸ª PO å·²æ’å…¥çš„ Order Item æ•°

        processLines.forEach((line, lineIndex) => {
            try {
                const parsed = parseOELine(line);
                const poNumber = parsed.poNumber.trim();

                console.log(`  ğŸ“Œ å¤„ç†è¡Œ ${lineIndex}: PO=${poNumber}, OrderItemID=${parsed.orderItemId}`);

                // è·³è¿‡ PO number ä¸ºç©ºçš„è¡Œï¼ˆæ— æ•ˆæ•°æ®ï¼‰
                if (!poNumber) {
                    console.log(`    âš ï¸  è·³è¿‡ï¼šPO å·ä¸ºç©º`);
                    return;
                }

                if (poMap.has(poNumber)) {
                    // æ–¹æ¡ˆ Aï¼šPO å­˜åœ¨ â†’ åœ¨è¯¥ PO çš„æœ€åä¸€è¡Œåæ’å…¥ order item è¡Œ
                    // è®¡ç®—è¯¥ PO å·²æ’å…¥çš„ Order Item æ•°
                    const alreadyInserted = poInsertionCount.get(poNumber) ?? 0;

                    const rowIndices = poMap.get(poNumber)!;
                    const lastRowIndex = rowIndices[rowIndices.length - 1];
                    const insertIndex = lastRowIndex + alreadyInserted + 1;

                    const orderItemRow = buildOrderItemRow(parsed, columnCount);
                    insertions.push({ index: insertIndex, rows: [orderItemRow] });

                    console.log(`    âœ“ PO å­˜åœ¨äºè¡Œ ${rowIndices}ï¼Œåœ¨ç´¢å¼• ${insertIndex} å¤„æ’å…¥ Order Item è¡Œ`);

                    // æ›´æ–°è¯¥ PO çš„å·²æ’å…¥æ•°
                    poInsertionCount.set(poNumber, alreadyInserted + 1);
                    rowIndices.push(insertIndex);
                } else {
                    // æ–¹æ¡ˆ Bï¼šPO ä¸å­˜åœ¨ â†’ å…ˆæ’å…¥ PO è¡Œï¼Œå†æ’å…¥ order item è¡Œï¼ˆéƒ½åœ¨æœ«å°¾ï¼‰
                    const insertIndex = values.length + newPoInsertionOffset;

                    const poRow = buildPORow(parsed, columnCount);
                    const orderItemRow = buildOrderItemRow(parsed, columnCount);
                    insertions.push({ index: insertIndex, rows: [poRow, orderItemRow] });

                    console.log(`    âœ“ PO ä¸å­˜åœ¨ï¼Œåœ¨ç´¢å¼• ${insertIndex} å¤„æ’å…¥ PO è¡Œ + Order Item è¡Œ`);

                    newPoInsertionOffset += 2;
                    poMap.set(poNumber, [insertIndex, insertIndex + 1]);
                }
            } catch (e) {
                console.log(`    âŒ å¤„ç†è¡Œ ${lineIndex} æ—¶å‡ºé”™:`, e);
            }
        });

        console.log(`âœ“ æ€»æ’å…¥æ“ä½œæ•°: ${insertions.length}`);

        // ============ é˜¶æ®µ 4ï¼šé€†åºæ‰§è¡Œæ’å…¥ï¼ˆé¿å…ç´¢å¼•æ··ä¹±ï¼‰============
        console.log("ğŸ”„ [é˜¶æ®µ 4] é€†åºæ‰§è¡Œæ’å…¥...");
        for (let i = insertions.length - 1; i >= 0; i--) {
            try {
                const { index, rows } = insertions[i];
                values.splice(index, 0, ...rows);
                console.log(`  âœ“ æ’å…¥ ${i}: åœ¨ç´¢å¼• ${index} å¤„æ’å…¥ ${rows.length} è¡Œ`);
            } catch (e) {
                console.log(`  âŒ æ’å…¥ ${i} æ—¶å‡ºé”™:`, e);
            }
        }

        console.log(`âœ“ æ’å…¥åçš„è¡¨è¡Œæ•°: ${values.length}`);

        // ============ é˜¶æ®µ 5ï¼šä¸€æ¬¡æ€§å†™å› Excel============
        console.log("ğŸ’¾ [é˜¶æ®µ 5] å†™å› Excel...");
        try {
            console.log(`  è°ƒè¯•: dataRange è¡Œæ•°=${dataRange.getRowCount()}, åˆ—æ•°=${dataRange.getColumnCount()}`);
            console.log(`  è°ƒè¯•: values è¡Œæ•°=${values.length}, åˆ—æ•°=${values[0]?.length || 0}`);

            // å¦‚æœè¡Œæ•°ä¸åŒ¹é…ï¼Œæ·»åŠ ç¼ºå°‘çš„è¡Œ
            if (dataRange.getRowCount() !== values.length) {
                console.log(`  âš ï¸  è¡Œæ•°ä¸åŒ¹é…ï¼ˆ${dataRange.getRowCount()} â†’ ${values.length}ï¼‰ï¼Œæ·»åŠ æ–°è¡Œ...`);

                const rowDiff = values.length - dataRange.getRowCount();
                console.log(`  ğŸ“Œ éœ€æ·»åŠ  ${rowDiff} è¡Œ`);

                // å‡†å¤‡å›æ·»åŠ çš„è¡Œ
                const newRows: (string | number | boolean)[][] = [];
                for (let i = 0; i < rowDiff; i++) {
                    const emptyRow: (string | number | boolean)[] = new Array(columnCount).fill('');
                    newRows.push(emptyRow);
                }

                // ä¸€æ¬¡æ€§æ·»åŠ å¤šè¡Œ
                table.addRows(-1, newRows);
                console.log(`  âœ“ ä¸€æ¬¡æ€§æ·»åŠ  ${rowDiff} è¡Œ`);

                // é‡æ–°è·å–æ‰©å±•åçš„èŒƒå›´
                const newDataRange = table.getRangeBetweenHeaderAndTotal();
                newDataRange.setValues(values);
                console.log(`âœ… å®Œæˆ - å·²å°† ${values.length} è¡Œæ•°æ®å†™å› Excel`);
            } else {
                dataRange.setValues(values);
                console.log(`âœ… å®Œæˆ - æ‰€æœ‰æ•°æ®å·²å†™å› Excel`);
            }
        } catch (e) {
            console.log(`âŒ å†™å›æ•°æ®æ—¶å‡ºé”™:`, e);
            return;
        }
    } catch (e) {
        console.log(`âŒ è„šæœ¬æ‰§è¡Œå‡ºé”™:`, e);
    }
}

/**
 * è§„èŒƒåŒ– CSV è¡Œï¼Œå¤„ç†å¯èƒ½çš„ JSON æ•°ç»„æ ¼å¼å’Œå¼•å·
 */
function normalizeLine(line: string): string {
    try {
        const trimmed = line.trim();

        // å¤„ç† ["xxx"] è¿™ç§ stringify
        if (trimmed.startsWith('[')) {
            const parsed: unknown = JSON.parse(trimmed);

            if (
                Array.isArray(parsed) &&
                parsed.length > 0 &&
                typeof parsed[0] === 'string'
            ) {
                return parsed[0];
            }
        }

        // å»æ‰é¦–å°¾å¼•å·
        return trimmed.replace(/^"|"$/g, '');
    } catch (e) {
        console.log(`normalizeLine å‡ºé”™:`, e);
        return line.trim();
    }
}

/**
 * è§£æ OE CSV è¡Œï¼Œæå–å…³é”®å­—æ®µ
 * CSV åˆ—é¡ºåº: [0]=Job#, [1]=?, [2]=Candu, [3]=#, [4]=DrawingNum, [5]=Rev, [6]=Expeditor, 
 *           [7]=OEDate, [8]=?, [9]=Description, [10]=POéƒ¨åˆ†, [11]=PO, [12-15]=?, [15]=DeliveryDate, ..., [26]=OrderItemID
 */
function parseOELine(line: string): {
    orderItemId: string;
    poNumber: string;
    expeditor: string;
    drawingNumber: string;
    description: string;
    revision: string;
    jobNumber: string;
    oeDate: string;
    deliveryDate: string;
} {
    try {
        const actualLine = normalizeLine(line);
        const values = actualLine.split(',');

        if (values.length < 27) {
            console.log(`    âš ï¸  è­¦å‘Šï¼šCSV è¡Œçš„å­—æ®µæ•°ä¸è¶³ï¼ˆæœŸæœ› 27ï¼Œå®é™… ${values.length}ï¼‰`);
        }

        return {
            orderItemId: values[26]?.trim() ?? '',    // ç¬¬ 27 åˆ—
            poNumber: values[11]?.trim() ?? '',       // ç¬¬ 12 åˆ—
            expeditor: values[6]?.trim() ?? '',       // ç¬¬ 7 åˆ—
            drawingNumber: values[4]?.trim() ?? '',   // ç¬¬ 5 åˆ—
            description: values[9]?.trim() ?? '',     // ç¬¬ 10 åˆ—
            revision: values[5]?.trim() ?? '',        // ç¬¬ 6 åˆ—
            jobNumber: values[0]?.trim() ?? '',       // ç¬¬ 1 åˆ—ï¼ˆæ”¹ä¸º 0ï¼‰
            oeDate: values[7]?.trim() ?? '',         // ç¬¬ 8 åˆ—
            deliveryDate: values[15]?.trim() ?? '',   // ç¬¬ 16 åˆ—
        };
    } catch (e) {
        console.log(`    âŒ parseOELine å‡ºé”™:`, e);
        throw e;
    }
}

/**
 * æ„é€  PO è¡Œï¼ˆå¡«å……å¤šä¸ªå­—æ®µï¼‰
 */
function buildPORow(parsed: ReturnType<typeof parseOELine>, columnCount: number): (string | number | boolean)[] {
    if (!parsed.poNumber) {
        console.log(`    âŒ buildPORow: PO number ä¸ºç©º`);
        throw new Error("PO number cannot be empty");
    }
    const rowData: (string | number | boolean)[] = new Array(columnCount).fill('');
    // è¡¨çš„åˆ—é¡ºåºï¼š[0]=Order Item ID, [1]=PO, [2-19]=å…¶ä»–åˆ—
    rowData[0] = '';                      // Order Item ID ä¸ºç©ºï¼ˆè¿™æ˜¯ PO è¡Œï¼Œä¸æ˜¯ Order Itemï¼‰
    rowData[1] = parsed.poNumber;         // PO
    rowData[2] = parsed.expeditor;        // Expeditor
    rowData[3] = '';    // Drawing Number
    rowData[4] = '';      // Description
    rowData[5] = '0';         // Revision
    rowData[6] = '';        // Job Number
    rowData[7] = parsed.oeDate;          // OE Date
    rowData[8] = parsed.deliveryDate;    // Delivery Date
    return rowData;
}

/**
 * æ„é€  Order Item è¡Œ
 */
function buildOrderItemRow(
    parsed: ReturnType<typeof parseOELine>,
    columnCount: number
): (string | number | boolean)[] {
    if (columnCount < 2) {
        console.log(`    âŒ buildOrderItemRow: åˆ—æ•°ä¸è¶³ï¼ˆ${columnCount} < 2ï¼‰`);
        throw new Error(`Column count ${columnCount} is less than required 2`);
    }
    const rowData: (string | number | boolean)[] = new Array(columnCount).fill('');
    // è¡¨çš„åˆ—é¡ºåºï¼š[0]=Order Item ID, [1]=PO, [2-19]=å…¶ä»–åˆ—
    rowData[0] = parsed.orderItemId;      // Order Item ID
    rowData[1] = parsed.poNumber;         // PO
    rowData[2] = parsed.expeditor;        // Expeditor (å¦‚æœæœ‰å¯¹åº”åˆ—)
    rowData[3] = parsed.drawingNumber;    // Drawing Number (å¦‚æœæœ‰å¯¹åº”åˆ—)
    rowData[4] = parsed.description;      // Description (å¦‚æœæœ‰å¯¹åº”åˆ—)
    rowData[5] = parsed.revision;         // Revision (å¦‚æœæœ‰å¯¹åº”åˆ—)
    rowData[6] = "J# " + parsed.jobNumber;       // Job Number (å¦‚æœæœ‰å¯¹åº”åˆ—)
    rowData[7] = parsed.oeDate;         // OE Date (å¦‚æœæœ‰å¯¹åº”åˆ—)
    rowData[8] = parsed.deliveryDate;   // Delivery Date (å¦‚æœæœ‰å¯¹åº”åˆ—)
    // å¯æ ¹æ®å®é™…åˆ—é¡ºåºç»§ç»­æ˜ å°„å…¶ä»–å­—æ®µ
    return rowData;
}